//AUTHOR:		DANIEL CRISP
//DESC:			parseSet NOTES

/*
Whats left to do....
Create aliasmap array.
Put values to 
*/


	// Request Filenames From User
	//char *inpfile = request_filename("Enter input filename:\n"); //Worked, but wanted to use non-pointed char array
	//inpfile = request_filename("Enter input filename:\n"); //Cannot assign to char[40]
	strcpy(inpfile,request_filename("Enter saveset filename:\n"));

//inpfile = request_filename("Enter Array to sort:\n"); assignment to char [40] allowed with strcpy...




HAVE SAVESET DATA
HAVE ALIASMAP DATA

WANT TO CREATE OBJECTS WITH SET/RD NAMES, & VALUES.
	THEN REPLACE OLD NAMES IF SEEN
	AND PARSE NAME INTO MACROS
	AND OUTPUT TRANSLATED NAMES

parseSet.cpp(`140): error C2664: 'unsigned int std::basic_string<char,std::char_traits<char>,std::allocator<char>>::copy(_Elem *, unsigned int, unsigned int) const': cannot convert argument 1 from 'std::string' to 'char *'
	with
	[
		_Elem=char
	]

apparently...
I DO NOT RETURN a name_set value matching "REA_BTS23:PSD_D1155:I_CSET" when I inlcude the first part...

1)
char *setStr = new char[name_set[0].length() + 1];
strcpy(setStr, name_set[0].c_str());
cout << "\nj: " << 0 << "\tGets us " << setStr << "...";
delete [] setStr;/**/

2)
string Str = ("REA_BTS23:PSD_D1155:I_CSET");
	for (int j = 0; j < num[0]; ++j) {
		if (Str.compare(name_set[j])==0) {
			cout << "\nFound set at j equals " << j << endl;
		} else if (Str.compare(name_read[j])==0) {
			cout << "\nFound read at j equals " << j << endl;
		} else if (j==num[0]-1) {
			cout << "\nNOT FOUND\n";
		}
	}


TRIED TO ADD VECTOR STRUCT:
#include<vector>
class S
{
	string oldStr;
	string newStr;
	public:
		S(string ostr, string nstr) {
			set(ostr, nstr);
		}
		S() {}
		void set(string ostr, string nstr) {
			oldStr = ostr;
			newStr = nstr;
		}
		
};

vector<S> mapVec;
	
while (!finMap.eof()) {
	get_data(finMap, name_old, name_new, i);
	aliasmap[name_old[i]] = name_old[i];
	S s(name_old[i], name_new[i]);
	mapVec.push_back(s);
	i++;
}
//Last position is 0:0, so Its easier to tell later on if std::find failed
S s("0","0");
mapVec.push_back(s);

and later on, in a loop where I was getting saveset data... I was going to try this:
//find(mapVec.old.begin(),mapVec.old.end(), name_set[i]);



/*Can't switch 'char *'
switch(inpfile) {
		case "value_set":
			bubblesort(value_set, index, MAX_LINES_PER_FILE);
		case "value_read":
			bubblesort(value_read, index, MAX_LINES_PER_FILE);
}*/
	
	
/* USE BUBBlE SORT AFTER PARSING D#### FROM TRANSLATED CHAR ARRAY
cout << "\n\nSORTING INPUT:\n\n";
bubblesort(value_set[], index[], MAX_LINES_PER_FILE);
*/